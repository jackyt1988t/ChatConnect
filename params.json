{
  "name": "Websocket",
  "tagline": "WebSocket",
  "body": "# MyWebSocket\r\n## WebSocket Server написанный на языке c#.\r\n<div>\r\n\tПоддержка .NET Framework 4.5, Mono 4.2 <br>\r\n\thttp://jackyt1988t.github.io/WebSocket <br>\r\n\tВ данный момент поддерживается: <br>\r\n\tWebSocket Протокол Sample - требует тестов https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-03 <br>\r\n\tWebSocket Протокол №13(RFC6455) - требует тестов https://tools.ietf.org/html/rfc6455 <br>\r\n</div>\r\n\r\n## С чего начать?\r\n\r\n<div>\r\n\tДля того чтобы начать обрабатывать входящие подключения WebSocket клиентов необходимо подписаться на статическое\r\n\tсобытие EventConnect класса ws, событие наступает если клиент инициирует переход c протокола http на websocket.\r\n\tБыл был указан заголвок Upgrade: websocket и версия websocket поддерживается данной реализацией.\r\n</div>\r\n\r\n```C#\r\n\r\n\tusing ChatConnect.Tcp;\r\n\tusing ChatConnect.Tcp.Protocol.WS;\r\n\r\n\tWS.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"был выполнен переход на websocket\");\r\n\t};\r\n\t\r\n\t// Запуск Сервера\r\n\tWServer Server = new WServer(\"0.0.0.0\", 8081, 2);\r\n```\r\n\r\n## Как обрабатывать?\r\n\r\n<div>\r\n\tЕсли после события EventConnect обработка заголвоков закончится успехом наступит событие EventOnOpen. заголвки\r\n\tбудут отправлены после обработки всех подписчиков на событие EventOnOpen данного экземпляра websocket.\r\n</div>\r\n\r\n```C#\r\n\r\n\tusing ChatConnect.Tcp.Protocol.WS;\r\n\r\n\tWS.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"был выполнен переход на websocket\");\r\n\t\tWS ws = obj as WS;\r\n\t\tws.EventOnOpen += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\tConsole.WriteLine(\"Заголовки были получены и установлены\");\r\n\t\t\tConsole.WriteLine(\"Входящие заголовки:\\r\\n\" + ws.Request.ToString());\r\n\t\t\tConsole.WriteLine(\"Исходящие заголовки:\\r\\n\" + ws.Response.ToString());\r\n\t\t};\r\n\t};\r\n\r\n```\r\n\r\n<div>\r\n    При получение днных могут произойти несколько событий, точнее два, это EventChunk и EventData. Событие EventChuck\r\n    наступает если удаленная сторона отправляет данные по частям, что предусмотрено всеми версиями websocket, например\r\n    в версии 13 удаленная сторона должна в первом фрейме указать Опкод данных(Text, Binnary) и бит FIN равным 0,\r\n    далее следует 0 или несколько фреймов где опкод равен(Continuation), а бит FIN равен 0 и последним всегда должен\r\n    приходить фрейм с опкодом(Continuation) и битом FIN равным 1, он же может быть одним единственным фреймом. Когда\r\n    все данные получены наступает событие EventData.\r\n</div>\r\n\r\n```C#\r\n\r\n\tusing ChatConnect.Tcp.Protocol.WS;\r\n\r\n\tWS.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"был выполнен переход на websocket\");\r\n\t\tWS ws = obj as WS;\r\n\t\tList<byte[]> Data = new List<byte[]>();\r\n\t\tList<string> Text = new List<string>();\r\n\t\tws.EventData += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\t// Информация о полученных данных\r\n\t\t\tWSData data = e.sender as WSData;\r\n\r\n\t\t\tif (data.Opcod == WSOpcod.Text)\r\n\t\t\t{\r\n\t\t\t\tText.Add(data.ToString());\r\n\t\t\t\t// обрабатываем данные\r\n\t\t\t}\r\n\t\t\telse if (data.Opcod == WSOpcod.Binnary)\r\n\t\t\t{\r\n\t\t\t\tData.Add(data.ToByte());\r\n\t\t\t\t// обрабатываем данные \r\n\t\t\t}\r\n\r\n\t\t};\r\n\t\tws.EventChunk += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\tif (data.Opcod == WSOpcod.Text)\r\n\t\t\t{\r\n\t\t\t\tText.Add(data.ToString());\r\n\t\t\t}\r\n\t\t\telse if (data.Opcod == WSOpcod.Binnary)\r\n\t\t\t{\r\n\t\t\t\tData.Add(data.ToByte());\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n```\r\n\r\n<div>\r\n\tПоследним всегда наступает событие EventClose было соединение закрыто чисто или произошла ошибка.\r\n</div>\r\n\r\n```C#\r\n\r\n\tusing ChatConnect.Tcp.Protocol.WS;\r\n\r\n\tWS.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"был выполнен переход на websocket\");\r\n\t\tWS ws = obj as WS;\r\n\t\tws.EventClose += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\tConsole.WriteLine(e.sender.ToString());\r\n\t\t};\r\n\t};\r\n\r\n```\r\n\r\n## Что с ошибками?\r\n\r\n<div>\r\n\tВсе критисекие ошибки будут записаны в файл log.log где раполагается запущенный сервер. Ошибки обрабатывается\r\n\tв событие EventError\r\n</div>\r\n\r\n```C#\r\n\r\n\tusing ChatConnect.Tcp.Protocol.WS;\r\n\r\n\tWS.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"был выполнен переход на websocket\");\r\n\t\tWS ws = obj as WS;\r\n\t\tws.EventError += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\tConsole.WriteLine(e.sender.ToString());\r\n\t\t};\r\n\t};\r\n\r\n```\r\n\r\n<div>\r\n\tЧтобы включить отладочную информацию необходимо установить свойство WS.Debug = true\r\n\tОтладочная информация:\r\n</div>\r\n<img src=\"/MyWebSocketDebug.png\" alt=\"Отладочная информация\">\r\n\r\n# Средствами сервера можно обрабатывать HTTP запросы и устанавливать LongPolling соединения\r\n\r\n## С чего начать?\r\n\r\n<div>\r\n\tДля того чтобы начать обрабатывать входящие подключения HTTP необходимо подписаться на статическое\r\n\tсобытие EventConnect класса HTTP, событие наступает когда устанавливается новое tcp/ip соеинение.\r\n</div>\r\n\r\n```C#\r\n\tusing ChatConnect.Tcp.Protocol.HTTP;\r\n\t\r\n\tHTTP.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"Установлено новое http соедиение\");\r\n\t};\r\n```\r\n\r\n<div>\r\n\tпосле того как будут получены заголвоки и не будет инициирован переход на протокол WebSocket, наступает\r\n\tсобытие EventOnOpen, данное событие наступает перед началом приема данных(если таковые имеются). Так же\r\n\tдо данного события будут установлены некоторые заголвки:\r\n\tDate\r\n    Server\r\n    Connection(если необходимо)\r\n    Content-Encoding(если в заголвоке Accept-Encoding указаны gzip или deflate)\r\n\tTransfer-Encoding\r\n\t\r\n\tВ данной реализации поддерживается сжатие gzip и deflate Чтобы не сжимать данные надо присвоить заголвоку \r\n\tContent-encoding null или пустую строку. По умолчанию данные отправляются в кодировке chunked, \r\n\tпосле отправки всех данных необходимо вызвать ф-цию Flush(), чтобы очистить все буфферы и если используется\r\n\tкодмровка chuncked отправить заврешающий блок данных.\r\n</div>\r\n\r\n```C#\r\n\tusing ChatConnect.Tcp.Protocol.HTTP;\r\n\t\r\n\tHTTP.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"Установлено новое http соедиение\");\r\n\t\t\r\n\t\tHTTP http = obj as HTTP;\r\n\t\t\r\n\t\tws.EventOnOpen += (object obj, PEventArgs a) =>\r\n\t\t{\r\n\t\t\tConsole.WriteLine(\"Заголовки были получены и установлены\");\r\n\t\t\tConsole.WriteLine(\"Входящие заголовки:\\r\\n\" + ws.Request.ToString());\r\n\t\t\tConsole.WriteLine(\"Исходящие заголовки:\\r\\n\" + ws.Response.ToString());\r\n\t\t\t\r\n\t\t};\r\n\t};\r\n```\r\n\r\n<div>\r\n\tПосле ролучения всех данных(если имеются) наступает событие EventData. ниже приведен пример обработки longpolling\r\n\tи отправка статических файлов. Заголвоки можно изменить только до их отправки, иначе будет выброшено исключение,\r\n\tинформацию о котором можно будет прочитать в файле log.log в корневой папке с проектом.\r\n</div>\r\n\r\n```C#\r\n\tusing ChatConnect.Tcp.Protocol.HTTP;\r\n\t\r\n\t// Список подписчиков longpolling\r\n\tList<HTTP> Pollings = new List<HTTP>();\r\n\t\r\n\tHTTP.EventConnect += (object obj, PEventArgs a) =>\r\n\t{\r\n\t\tConsole.WriteLine(\"HTTP\");\r\n\t\tHTTP Http = obj as HTTP;\r\n\t\tbool polling = false;\r\n\t\t// здесь можно проверить правильность заголовков\r\n\t\tHttp.EventOnOpen += (object sender, PEventArgs e) =>\r\n\t\t{\t\r\n\t\t\tConsole.WriteLine(\"OPEN\");\r\n\t\t};\r\n\t\t\r\n\t\t// Событие наступает когда приходят новые данные\r\n\t\tHttp.EventData += (object sender, PEventArgs e) =>\r\n\t\t{\r\n\t\t\tswitch (Http.Request.Path)\r\n\t\t\t{\r\n\t\t\t\tcase \"/\":\r\n\t\t\t\t\t// асинхроноо отправляет файл\r\n\t\t\t\t\tHttp.File(\"Html/index.html\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"/message\":\r\n\t\t\t\t\tlock (Pollings)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int i = 0; i < Pollings.Count; i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tPollings[i].Flush(Http.Request._Body);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!polling)\r\n\t\t\t\t\t\t\tHttp.Flush(\"Данные получены\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"/subscribe\":\r\n\t\t\t\t\t\tpolling = true;\r\n\t\t\t\t\t\tlock (Pollings)\r\n\t\t\t\t\t\t\tPollings.Add(Http);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tHttp.File(\"Html\" + Http.Request.Path);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tHttp.EventError += (object sender, PEventArgs e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tConsole.WriteLine(\"ERROR\");\r\n\t\t\t\t};\r\n\t\t\t\tHttp.EventClose += (object sender, PEventArgs e) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (polling)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlock (Pollings)\r\n\t\t\t\t\t\t\tPollings.Remove(Http);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tConsole.WriteLine(\"CLOSE\");\r\n\t\t\t\t};\r\n\t\t\t};\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}